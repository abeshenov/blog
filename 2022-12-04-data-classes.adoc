= Data transfer objects, records, and data classes
:author: Alexey Beshenov
:docdatetime: 2022-12-04T00:00-06:00
:source-highlighter: highlightjs
:highlightjs-languages: java, kotlin
:toc:

This is my first note about *pragmatic Java programming*.
We will investigate some basic things and try to understand why they are the way they are.
Sometimes it is also instructive to look at other JVM languages and see how they
solve typical Java problems. We will notably use link:https://kotlinlang.org/[Kotlin].

This not is a part of link:Ã­ndex.html[my blog].

Like it or not, a large part of programming concerns
link:https://en.wikipedia.org/wiki/Data_transfer_object[*data transfer objects*].
Their only purpose is to... transfer data. Some languages have great support for
data transfer objects out of the box, while other languages make it unnecessarily
awkward. This is not unique to object oriented programming; e.g.
link:http://learnyouahaskell.com/making-our-own-types-and-typeclasses[Haskell has `data` type declaration]
which works well for defining data structures. 
But here we will talk about Java, where historically working with data transfer
objects was clumsy.

image::2022-12-04-data-classes-cover.jpg[]

In Java, data transfer objects are often called *POJOs* (plain old Java objects),
or *JavaBeans* (name coming from an
link:https://www.oracle.com/java/technologies/javase/javabeans-spec.html[old API from Sun]
and its conventions),
even though these terms have slightly different meanings and origins.

Since JDK 14, Java has *records*, a special kind of classes that serve like
data carriers. In Kotlin, there are *data classes* that cover the same needs
and actually work better than records.


== The old Java way

To fix a concrete example, suppose we have the following data structure:

- `userId` : `long`
- `login` : `String`
- `active` : `boolean`
- `email` : `String`
- `displayName` : `String`, possibly `null`
- `githubAccount` : `String`, possibly `null`

In good old Java, we would start with defining a class with all necessary
private fields, and then the IDE (or link:https://projectlombok.org/[Lombok])
can automatically generate a constructor, setters, `equals`, `hashCode`, and `toString`.
The result will look as follows.

[source, java]
----
public class User {
    private final long userId;
    private final String login;
    private final boolean active;
    private final String email;
    private final String displayName;
    private final String githubAccount;

    public User(
            long userId,
            String login,
            boolean active,
            String email,
            String displayName,
            String githubAccount
    ) {
        this.userId = userId;
        this.login = login;
        this.active = active;
        this.email = email;
        this.displayName = displayName;
        this.githubAccount = githubAccount;
    }

    public long getUserId() {
        return userId;
    }

    public String getLogin() {
        return login;
    }

    public boolean isActive() {
        return active;
    }

    public String getEmail() {
        return email;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getGithubAccount() {
        return githubAccount;
    }

    @Override
    public boolean equals(Object o) {
        // Auto-generated code
    }

    @Override
    public int hashCode() {
        // Auto-generated code
    }

    @Override
    public String toString() {
        // Auto-generated code
    }
}
----

Every Java programmer knows to go quickly over such standard code.
It is always the same, most of the time generated by the IDE.
It will raise some eyebrows if getters and setters have extra logic implemented.

We declared fields as final and only defined getters because we would like
to keep our data immutable.

There is a serious problem with this code.

First, it is
link:https://wiki.c2.com/?StringlyTyped["stringly typed"]:
it uses the same `String` type to express different data.
Some people argue that you need to wrap almost everything in domain-specific types:
e.g., you'd never pass "joe@gmail.com", but instead a value of designated type
`Email("joe@gmail.com")`.

However, as we see, creating types in Java is a bit tedious.

Another related problem is that the constructor has too many arguments,
many of them indistinguishable, having the same type. Creating a `User`
manually is very hard as a consequence.

A common solution to this problem is to define setters, so that the
object can be configured field by field.

[source, java]
----
public class User {
    private long userId;
    private String login;
    private boolean active;
    private String email;
    private String displayName;
    private String githubAccount;

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    // Similar getters and setters for other fields
}
----

Another common style is "builder setters",
where `setFoo(...)` returns `this`:

[source, java]
----
public class User {
    // Private fields

    public long getUserId() {
        return userId;
    }

    public User setUserId(long userId) {
        this.userId = userId;
        return this;
    }

    public String getLogin() {
        return login;
    }

    public User setLogin(String login) {
        this.login = login;
        return this;
    }

    // etc.
}
----

This allows chained calls:

[source, java]
----
final var user = new User().setUserId(123)
        .setLogin("cadadr")
        .setActive(true)
        .setDisplayName("Alexey Beshenov")
        .setEmail("cadadr@gmail.com")
        .setGithubAccount("abeshenov");
----

This approach to configuring fields has its own problems. We made all fields
mutable through setters, so we can't treat our `User` objects as immutable values.
We also don't know if the constructed instances are valid, e.g., whether we set
all required fields.

To make sure that we always construct valid objects, we can use the classical
link:https://refactoring.guru/design-patterns/builder[*builder pattern*].
There our builder would verify if all necessary fields are set, and we can also
return a "frozen", immutable object (without setters).

For more details, see
Item 2 in _Joshua Bloch, Effective Java. Third Edition_.

To have a kind of "setters" that don't mutate data, we can define methods that
return a *new instance* of `User`. It would be misleading to use names like
`setFoo(...)` in this case, we would rather use `withFoo(...)`:

[source, java]
----
public class User {

    public User withUserId(long userId);
    public User withLogin(String login);
    public User withActiveStatus(boolean active);
    public User withEmail(String email);
    public User withDisplayName(String displayName);
    public User withGithubAccount(String githubAccount);

    // Getters
}
----

Sadly, it is a very common Java convention for a class to have a zero-argument
constructor and getters and setters for each field. Libraries like
link:https://github.com/FasterXML/jackson[Jackson] expect this when
deserializing classes: they create an instance and then set different fields
with setters. Class fields are discovered by introspection: a field `foo`
is expected to be accessible through `getFoo()` and `setFoo(...)`.


== Prominent example: FHIR

The library
link:https://github.com/hapifhir/org.hl7.fhir.core[`ca.uhn.hapi.fhir:org.hl7.fhir.r4`]
is all about "data transfer objects". It defines many resources and data types from
link:https://hl7.org/fhir/[FHIR], a sophisticated standard for health care data exchange.

For instance, there is a class
link:https://hapifhir.io/hapi-fhir/apidocs/hapi-fhir-structures-r4/org/hl7/fhir/r4/model/Patient.html[`org.hl7.fhir.r4.model.Patient`]
that represents
link:https://hl7.org/fhir/patient.html[various data related to a patient].

This class has a lot inside. It also makes part of a
link:https://hapifhir.io/hapi-fhir/apidocs/hapi-fhir-structures-r4/org/hl7/fhir/r4/model/package-tree.html[nontrivial class hierarchy].

[source, java]
----
public class Patient extends DomainResource {
    protected List<Identifier> identifier;
    protected BooleanType active;
    protected List<HumanName> name;
    protected List<ContactPoint> telecom;
    protected Enumeration<Enumerations$AdministrativeGender> gender;
    protected DateType birthDate;
    protected Type deceased;
    protected List<Address> address;
    protected CodeableConcept maritalStatus;
    protected Type multipleBirth;
    protected List<Attachment> photo;
    protected List<Patient$ContactComponent> contact;
    protected List<Patient$PatientCommunicationComponent> communication;
    protected List<Reference> generalPractitioner;
    protected List<Resource> generalPractitionerTarget;
    protected Reference managingOrganization;
    protected Organization managingOrganizationTarget;
    protected List<Patient$PatientLinkComponent> link;

    public static final String SP_IDENTIFIER;
    public static final ca.uhn.fhir.rest.gclient.TokenClientParam IDENTIFIER;
    public static final String SP_GIVEN;
    public static final ca.uhn.fhir.rest.gclient.StringClientParam GIVEN;
    // More constants...

    public Patient();

    public List<Identifier> getIdentifier();
    public Patient setIdentifier(List<Identifier>);
    public boolean hasIdentifier();
    public Identifier addIdentifier();
    public Patient addIdentifier(Identifier);
    public Identifier getIdentifierFirstRep();

    public BooleanType getActiveElement();
    public boolean hasActiveElement();
    public boolean hasActive();
    public Patient setActiveElement(BooleanType);
    public boolean getActive();
    public Patient setActive(boolean);

    public List<HumanName> getName();
    public Patient setName(List<HumanName>);
    public boolean hasName();
    public HumanName addName();
    public Patient addName(HumanName);
    public HumanName getNameFirstRep();

    public List<ContactPoint> getTelecom();
    public Patient setTelecom(List<ContactPoint>);
    public boolean hasTelecom();
    public ContactPoint addTelecom();
    public Patient addTelecom(ContactPoint);
    public ContactPoint getTelecomFirstRep();

    public Enumeration<Enumerations$AdministrativeGender> getGenderElement();
    public boolean hasGenderElement();
    public boolean hasGender();
    public Patient setGenderElement(Enumeration<Enumerations$AdministrativeGender>);
    public Enumerations$AdministrativeGender getGender();
    public Patient setGender(Enumerations$AdministrativeGender);

    public DateType getBirthDateElement();
    public boolean hasBirthDateElement();
    public boolean hasBirthDate();
    public Patient setBirthDateElement(DateType);
    public Date getBirthDate();
    public Patient setBirthDate(Date);

    public Type getDeceased();
    public BooleanType getDeceasedBooleanType() throws FHIRException;
    public boolean hasDeceasedBooleanType();
    public DateTimeType getDeceasedDateTimeType() throws FHIRException;
    public boolean hasDeceasedDateTimeType();
    public boolean hasDeceased();
    public Patient setDeceased(Type);

    public List<Address> getAddress();
    public Patient setAddress(List<Address>);
    public boolean hasAddress();
    public Address addAddress();
    public Patient addAddress(Address);
    public Address getAddressFirstRep();

    public CodeableConcept getMaritalStatus();
    public boolean hasMaritalStatus();
    public Patient setMaritalStatus(CodeableConcept);

    public Type getMultipleBirth();
    public BooleanType getMultipleBirthBooleanType() throws FHIRException;
    public boolean hasMultipleBirthBooleanType();
    public IntegerType getMultipleBirthIntegerType() throws FHIRException;
    public boolean hasMultipleBirthIntegerType();
    public boolean hasMultipleBirth();
    public Patient setMultipleBirth(Type);

    public List<Attachment> getPhoto();
    public Patient setPhoto(List<Attachment>);
    public boolean hasPhoto();
    public Attachment addPhoto();
    public Patient addPhoto(Attachment);
    public Attachment getPhotoFirstRep();

    public List<Patient$ContactComponent> getContact();
    public Patient setContact(List<Patient$ContactComponent>);
    public boolean hasContact();
    public Patient$ContactComponent addContact();
    public Patient addContact(Patient$ContactComponent);
    public Patient$ContactComponent getContactFirstRep();

    public List<Patient$PatientCommunicationComponent> getCommunication();
    public Patient setCommunication(List<Patient$PatientCommunicationComponent>);
    public boolean hasCommunication();
    public Patient$PatientCommunicationComponent addCommunication();
    public Patient addCommunication(Patient$PatientCommunicationComponent);
    public Patient$PatientCommunicationComponent getCommunicationFirstRep();

    public List<Reference> getGeneralPractitioner();
    public Patient setGeneralPractitioner(List<Reference>);
    public boolean hasGeneralPractitioner();
    public Reference addGeneralPractitioner();
    public Patient addGeneralPractitioner(Reference);
    public Reference getGeneralPractitionerFirstRep();
    public List<Resource> getGeneralPractitionerTarget();

    public Reference getManagingOrganization();
    public boolean hasManagingOrganization();
    public Patient setManagingOrganization(Reference);
    public Organization getManagingOrganizationTarget();
    public Patient setManagingOrganizationTarget(Organization);

    public List<Patient$PatientLinkComponent> getLink();
    public Patient setLink(List<Patient$PatientLinkComponent>);
    public boolean hasLink();
    public Patient$PatientLinkComponent addLink();
    public Patient addLink(Patient$PatientLinkComponent);
    public Patient$PatientLinkComponent getLinkFirstRep();

    protected void listChildren(List<Property>);
    public Property getNamedProperty(int, String, boolean) throws FHIRException;
    public Base[] getProperty(int, String, boolean) throws FHIRException;
    public Base setProperty(int, String, Base) throws FHIRException;
    public Base setProperty(String, Base) throws FHIRException;
    public Base makeProperty(int, String) throws FHIRException;
    public String[] getTypesForProperty(int, String) throws FHIRException;
    public Base addChild(String) throws FHIRException;
    public String fhirType();
    public Patient copy();
    public void copyValues(Patient);
    protected Patient typedCopy();
    public boolean equalsDeep(Base);
    public boolean equalsShallow(Base);
    public boolean isEmpty();
    public ResourceType getResourceType();
    public DomainResource copy();
    public Resource copy();
}
----

As you see, this uses "builder setters" style. This allows chained calls:

[source, java]
----
final var patient = new Patient()
    .setName(...)
    .setBirthDate(...)
    .setContact(...)
    .setPhoto(...);
----

In Kotlin, we can write calls to setters as field assignments:

[source, kotlin]
----
val patient = Patient()

patient.name = listOf(HumanName().setFamily("Dobbs").addGiven("Bob"))
patient.active = true
patient.gender = Enumerations.AdministrativeGender.MALE

// We can also do
with(patient) {
    name = listOf(HumanName().setFamily("Dobbs").addGiven("Bob"))
    active = true
    gender = Enumerations.AdministrativeGender.MALE
}

// Can use chained calls, if we like:
val contact = ContactPoint().setUse(ContactPoint.ContactPointUse.HOME)
    .setRank(0)
    .setValue("123-456-7890")

patient.telecom = listOf(contact)
----

Objects in the package `ca.uhn.hapi.fhir:org.hl7.fhir.r4` are quite complex
and require a
link:https://hapifhir.io/hapi-fhir/apidocs/hapi-fhir-structures-r4/org/hl7/fhir/r4/formats/IParser.html[custom serializer/deserializer to JSON].


== Mutable vs. immutable in JDK

Mutable objects with setters are everywhere in old Java.

For instance, the
link:https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Date.html[`java.util.Date`]
class has (now deprecated) methods
`setDate(...)`, `setHours(...)`, `setMinutes(...)`, `setMonth(...)`, `setSeconds(...)`, `setTime(...)`
that mutate the object and return `void`.

The modern API for working with date and time is in the
link:https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/package-summary.html[`java.time`]
package. There a class like
link:https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/LocalDateTime.html[`java.time.LocalDateTime`]
has no mutating setters. Instead, there are methods
`withDayOfMonth(...)`, `withDayOfYear(...)`, `withHour(...)`, `withMinute(...)`, `withMonth(...)`, `withNano(...)`, `withSecond(...)`, `withYear(...)`
that return a copy.

As you see, even JDK itself moves away from the old Java conventions.


== Java records

Java 14 finally introduced
link:https://docs.oracle.com/en/java/javase/17/language/records.html[*records*].
Our structure can be now written as

[source, java]
----
public record User(
        long userId,
        @NotNull String login,
        boolean active,
        @NotNull String email,
        @Nullable String displayName,
        @Nullable String githubAccount
) { }
----

I added `@NotNull` / `@Nullable` annotations.
Some people would go as far as using
link:https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Optional.html[`Optional`]
for optional values. This is a matter of taste; we'll not go into such details.

A record declaration is a syntactic sugar that generates

- a constructor taking values of all fields as arguments,
- a getter of the form `foo()` for each field `foo` (yes, it is `foo()`, not `getFoo()`),
- `equals(...)`, `hashCode()`, `toString()`.

Records are also implicitly final classes (can't be extended by subclasses).
They can't extend other classes either, but they can implement interfaces.

The above code is equivalent to the following.

[source, java]
----
public final class User {
    private final long userId;
    private final @NotNull String login;
    private final boolean active;
    private final @NotNull String email;
    private final @Nullable String displayName;
    private final @Nullable String githubAccount;

    public User(
            long userId,
            @NotNull String login,
            boolean active,
            @NotNull String email,
            @Nullable String displayName,
            @Nullable String githubAccount
    ) {
        this.userId = userId;
        this.login = login;
        this.active = active;
        this.email = email;
        this.displayName = displayName;
        this.githubAccount = githubAccount;
    }

    public long userId() {
        return userId;
    }

    public @NotNull String login() {
        return login;
    }

    public boolean active() {
        return active;
    }

    public @NotNull String email() {
        return email;
    }

    public @Nullable String displayName() {
        return displayName;
    }

    public @Nullable String githubAccount() {
        return githubAccount;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) return true;
        if (obj == null || obj.getClass() != this.getClass()) return false;
        var that = (User) obj;
        return this.userId == that.userId &&
                Objects.equals(this.login, that.login) &&
                this.active == that.active &&
                Objects.equals(this.email, that.email) &&
                Objects.equals(this.displayName, that.displayName) &&
                Objects.equals(this.githubAccount, that.githubAccount);
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, login, active, email, displayName, githubAccount);
    }

    @Override
    public String toString() {
        return "User[" +
                "userId=" + userId + ", " +
                "login=" + login + ", " +
                "active=" + active + ", " +
                "email=" + email + ", " +
                "displayName=" + displayName + ", " +
                "githubAccount=" + githubAccount + ']';
    }
}
----

When compiled to classes, records turn in the above thing.
E.g. if you inspect `User.class` with the `javap` tool, you'll see

[source, java]
----
public final class User extends Record {
    public User(long, String, boolean, String, String, String);
    public final String toString();
    public final int hashCode();
    public final boolean equals(Object);
    public long userId();
    public String login();
    public boolean active();
    public String email();
    public String displayName();
    public String githubAccount();
}
----

Luckily, we can know with reflection whether a class is a record and obtain
the list of its fields. Thanks to this, libraries like Jackson have support for
Java records and treat them the same way as old-school classes with
zero-arg constructor and setters.

There is still one important application where you can't use records: when your class
is a link:https://spring.io/guides/gs/accessing-data-jpa/[persistent `@Entity`].

It seems like
link:https://en.wikipedia.org/wiki/Jakarta_Persistence[object-relational mapping frameworks in Java]
expect persistent entities to follow the "JavaBean" style with zero-arg
constructor, setters and getters.
See e.g.
link:https://docs.jboss.org/hibernate/annotations/3.5/reference/en/html/entity.html[Hibernate's documentation].

However, keep in mind that `@Entities` are not meant to be the same as
data transfer objects.


== Pros and cons of records

The advantages of records are clear: they allow us to define immutable
data transfer objects without writing all the boilerplate code.

There are two obvious disadvantages.

1. The constructor depends on all fields at once, so it is very difficult
to manually create instances of complex records.

2. There is no method for obtaining a copy of record.
Ideally, we would like to have methods for copying with changing fields.

To summarize the situation, working with pure "data transfer objects" in Java
can be clumsy. Records reduce boilerplate code but don't solve all problems.
You can also apply the builder pattern to deal with too many parameters.


== Lombok

A popular alternative is code generation with
link:https://projectlombok.org/[Lombok]. It has annotations like
link:https://projectlombok.org/features/Builder[`@Builder`],
link:https://projectlombok.org/features/Data[`@Data`], and
link:https://projectlombok.org/features/Value[`@Value`]
that add all the boilerplate.

Modern IDEs understand Lombok, so it can be integrated with your tools.
However, it is still an extra development dependency.

Instead of extending Java with Lombok, why don't we consider different
JVM languages? I'm advocating for Kotlin, but in general it can be worth
investigating Clojure, Groovy, or Scala. For certain tasks they are better than
Java, and they run on top of the JVM.


== Data classes in Kotlin

Kotlin has
link:https://kotlinlang.org/docs/data-classes.html[**data classes**]
that work like Java records, and in fact give more flexibility.

The syntax is very simple:

[source, kotlin]
----
data class User(
    val userId: Long,
    val login: String,
    val email: String,
    val active: Boolean = true,
    val displayName: String? = null,
    val githubAccount: String? = null
)
----

Then the fields are accessed as `user.userId`, `user.login`, `user.email`,
etc. There are getters behind, but you don't see them in code.

Here we defined default values for some parameters. When we create an instance
of `User`, we can use field names.

[source, kotlin]
----
val user1 = User(123, "cadadr", "cadadr@github.com")

val user2 = User(
    userId = 123, githubAccount = "abeshenov", login = "cadadr", email = "cadadr@github.com"
)
----

We declared all fields with `val` because we normally want immutable values.

It is also possible to have `var` fields in a data class. Then we can call
setters with `obj.foo = newValue`. However, we should always be careful with
mutable objects.

If we want to modify fields of a data class, we should use `copy()`.
E.g. the following code doesn't change `user1`; instead it creates a copy
with `displayName` and `githubAccount` modified:

[source, kotlin]
----
val user1 = User(123, "cadadr", "cadadr@github.com")
val user2 = user1.copy(displayName = "Alexey Beshenov", githubAccount = "abeshenov")
----

To understand how this works under the hood, we can inspect the `User.class` file:

[source, java]
----
public final class User {
    public User(long, String, String, boolean, String, String);
    public final long getUserId();
    public final String getLogin();
    public final String getEmail();
    public final boolean isActive();
    public final String getDisplayName();
    public final String getGithubAccount();
    public final long component1();
    public final String component2();
    public final String component3();
    public final boolean component4();
    public final String component5();
    public final String component6();
    public final User copy(long, String, String, boolean, String, String);
    public String toString();
    public int hashCode();
    public boolean equals(Object);
}
----

So it generated

- constructors,
- getters for all fields,
- `componentN()` functions for accessing fields by their position,
- `copy(...)` method.
- `equals(...)`, `hashCode()`, `toString()`.

I omitted a couple of "synthetic" methods that allow to call `User(...)`
and `copy(...)` with default values from Kotlin.

This is a good example of how design patterns (builder) become obsolete
when the problem is already solved by the language
(named arguments and default values for them).

The `componentN()` functions are used internally for
link:https://kotlinlang.org/docs/destructuring-declarations.html[destructuring].
The destructuring is by position. The code like

[source, kotlin]
----
val (id, login, email) = user
----

will compile to

[source, kotlin]
----
val id    = user.component1()
val login = user.component2()
val email = user.component3()
----

This feature works well with types like
link:https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/-entry/[`Entry<K,V>`]
for map entries, so you can do things like

[source, kotlin]
----
val myMap = mapOf("foo" to 1, "bar" to 2, "baz" to 3)

myMap.forEach { (k,v) -> println("$k : $v") }

for ((k,v) in myMap) {
    println("$k : $v")
}
----

Similarly, destructuring is handy for simple types like
link:https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/[`Pair<A,B>`].

I see how this can work for established coordinate systems, like 3D coordinates
(x,y,z), or color coordinates like RGB / HSL / etc. But for most data classes
this kind of destructuring based on argument position can lead to confusing
code, unless there is some natural order of fields.


== References

- Joshua Bloch, Effective Java, 3rd ed.,
Item 2: Consider a builder when faced with many constructor parameters.

- Alexey Soshin, Kotlin Design Patterns and Best Practices, 2nd ed., 
Chapter 2: Working with Creational Patterns.

- link:https://docs.oracle.com/en/java/javase/17/language/records.html[Java Language Updates: Record Classes].

- link:https://kotlinlang.org/docs/data-classes.html[Data classes in Kotlin].

- link:https://kotlinlang.org/docs/functions.html[Named and default arguments for functions in Kotlin].

- link:https://kotlinlang.org/docs/destructuring-declarations.html#destructuring-in-lambdas[Destructuring declarations in Kotlin]

- link:https://refactoring.guru/design-patterns/builder[Builder pattern].
